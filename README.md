# E-Commerce Order Management API

A scalable REST API for an order management system with inventory tracking built with Laravel 12+ and PHP 8.2+.

## Project Overview

This is a comprehensive e-commerce order management system API that provides complete functionality for product management, inventory tracking, order processing, and user authentication. The system is designed with scalability in mind, featuring a clean architecture, efficient database design, and async processing capabilities.

### Key Highlights

- **RESTful API** built with Laravel 12+ and PHP 8.2+
- **JWT Authentication** with refresh token support
- **Role-Based Access Control** (Admin, Vendor, Customer)
- **Real-time Inventory Tracking** with low stock alerts
- **Order Management** with status workflow and inventory integration
- **Bulk Operations** for product import via CSV
- **Queue-based Processing** for async operations (emails, PDFs, alerts)
- **Comprehensive Testing** with feature and unit tests
- **API Documentation** via Postman collection

## Features

### Core Features

1. **Product & Inventory Management**

    - Product CRUD operations with variants support
    - Real-time inventory tracking with reserved quantities
    - Low stock alerts via queue jobs
    - Bulk product import via CSV [name, sku, description, price, quantity, is_active]
    - Product search with full-text search capabilities
    - Variant quantity management
    - Inventory updates trigger automatic low stock checks

2. **Order Processing**

    - Create orders with multiple items and variants
    - Order status workflow: Pending → Processing → Shipped → Delivered → Cancelled
    - Automatic inventory deduction on order confirmation
    - Order rollback on cancellation (restores inventory)
    - Invoice generation (PDF) via queue jobs
    - Email notifications for order updates
    - Order history tracking with timestamps

3. **Authentication & Authorization**
    - JWT authentication with refresh tokens
    - Role-based access control (RBAC)
    - **Admin**: Full system access
    - **Vendor**: Manage own products and orders
    - **Customer**: Place orders, view order history
    - Secure token management with expiration

## Local Setup Instructions

Follow these step-by-step instructions to set up the project locally:

### Prerequisites

- PHP 8.2 or higher
- Composer
- MySQL 8.0+ (or SQLite for development)
- Node.js and NPM (optional, for frontend assets)

### Step 1: Clone the Repository

```bash
git clone <repository-url>
cd ecom_api
```

### Step 2: Install Dependencies

```bash
composer install
```

### Step 3: Environment Configuration

```bash
# Copy the environment file
cp .env.example .env

# Generate application key
php artisan key:generate

# Generate JWT secret
php artisan jwt:secret
```

### Step 4: Configure Database

Edit the `.env` file and configure your database:

```env
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=ecom_api
DB_USERNAME=root
DB_PASSWORD=your_password
```

Or use SQLite for quick setup:

```env
DB_CONNECTION=sqlite
# DB_DATABASE will default to database/database.sqlite
```

### Step 5: Run Migrations

```bash
# Create database tables
php artisan migrate

# Seed database with sample data (optional)
php artisan db:seed
```

### Step 6: Start Development Server

```bash
php artisan serve
```

The API will be available at `http://127.0.0.1:8000`

### Step 7: Start Queue Worker (Required for Async Operations)

Open a new terminal window and run:

```bash
php artisan queue:work
```

**Important**: The queue worker is required for:
- Low stock alert emails
- Order confirmation emails
- Invoice PDF generation
- Order status update emails

### Step 8: Verify Installation

```bash
# Run tests
php artisan test

# Check API health
curl http://127.0.0.1:8000/up
```

### Optional: Seed Sample Data

To populate the database with sample products, orders, and users:

```bash
php artisan db:seed
```

This creates:
- 1 Admin user (`jbhasan@gmail.com` / `password123`)
- 3 Vendor users
- 10 Customer users
- 13 Products with variants
- 30 Sample orders

See `SEEDING_DATA.md` for details.

## Environment Variables Documentation

### Application Configuration

```env
APP_NAME="E-Commerce API"
APP_ENV=local
APP_KEY=base64:...                    # Generated by php artisan key:generate
APP_DEBUG=true                        # Set to false in production
APP_URL=http://127.0.0.1:8000
APP_TIMEZONE=UTC
```

### Database Configuration

```env
DB_CONNECTION=mysql                   # Options: mysql, sqlite, pgsql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=ecom_api
DB_USERNAME=root
DB_PASSWORD=                         # Your database password
```

**For SQLite (Quick Setup)**:
```env
DB_CONNECTION=sqlite
# DB_DATABASE defaults to database/database.sqlite
```

### JWT Authentication

```env
JWT_SECRET=                           # Generated by php artisan jwt:secret
JWT_TTL=60                           # Access token lifetime in minutes
JWT_REFRESH_TTL=20160                # Refresh token lifetime in minutes (14 days)
```

### Queue Configuration

```env
QUEUE_CONNECTION=database             # Options: database, redis
```

**For Redis Queue** (Recommended for production):
```env
QUEUE_CONNECTION=redis
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
```

### Mail Configuration

```env
MAIL_MAILER=smtp                     # Options: smtp, mailgun, ses, postmark
MAIL_HOST=mailhog                    # Use mailtrap.io or mailhog for development
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null                 # Options: tls, ssl
MAIL_FROM_ADDRESS=noreply@ecom.com
MAIL_FROM_NAME="${APP_NAME}"
```

**For Production (Gmail Example)**:
```env
MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=your-email@gmail.com
MAIL_PASSWORD=your-app-password
MAIL_ENCRYPTION=tls
```

### Cache Configuration

```env
CACHE_DRIVER=file                     # Options: file, redis, memcached
```

**For Redis Cache**:
```env
CACHE_DRIVER=redis
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
```

### Session Configuration

```env
SESSION_DRIVER=file                   # Options: file, database, redis
SESSION_LIFETIME=120                  # Minutes
```

### Logging

```env
LOG_CHANNEL=stack                     # Options: stack, single, daily, slack
LOG_LEVEL=debug                       # Options: emergency, alert, critical, error, warning, notice, info, debug
```

### Database Sharding (Optional)

```env
SHARD_COUNT=2
SHARD_1_HOST=127.0.0.1
SHARD_1_DATABASE=ecom_shard_1
SHARD_2_HOST=127.0.0.1
SHARD_2_DATABASE=ecom_shard_2
```

## API Authentication Guide

### Overview

The API uses **JWT (JSON Web Tokens)** for authentication. Each request to protected endpoints requires a valid access token in the Authorization header.

### Authentication Flow

#### 1. Register a New User

```bash
POST /api/v1/register
Content-Type: application/json

{
    "name": "John Doe",
    "email": "john@example.com",
    "password": "password123",
    "password_confirmation": "password123",
    "role": "customer"
}
```

**Response**:
```json
{
    "message": "User registered successfully",
    "user": {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com",
        "role": "customer"
    },
    "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
    "refresh_token": "random_refresh_token_string",
    "token_type": "bearer",
    "expires_in": 3600
}
```

#### 2. Login

```bash
POST /api/v1/login
Content-Type: application/json

{
    "email": "john@example.com",
    "password": "password123"
}
```

**Response**: Same format as registration

#### 3. Using Access Token

Include the access token in the Authorization header for all protected endpoints:

```bash
GET /api/v1/products
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGc...
```

#### 4. Refresh Access Token

When the access token expires, use the refresh token to get a new one:

```bash
POST /api/v1/refresh
Content-Type: application/json

{
    "refresh_token": "random_refresh_token_string"
}
```

**Response**:
```json
{
    "message": "Token refreshed successfully",
    "access_token": "new_access_token...",
    "refresh_token": "new_refresh_token...",
    "token_type": "bearer",
    "expires_in": 3600
}
```

#### 5. Get Authenticated User

```bash
GET /api/v1/me
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGc...
```

#### 6. Logout

```bash
POST /api/v1/logout
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGc...
```

### Token Expiration

- **Access Token**: Valid for 60 minutes (configurable via `JWT_TTL`)
- **Refresh Token**: Valid for 14 days (configurable via `JWT_REFRESH_TTL`)

### Role-Based Access

Different endpoints require different roles:

- **Public**: Register, Login
- **Authenticated**: All users can access basic endpoints
- **Admin/Vendor**: Product management, order management, inventory management
- **Customer**: Order creation, viewing own orders

### Error Responses

#### Invalid Credentials (401)
```json
{
    "message": "Unauthorized"
}
```

#### Token Expired (401)
```json
{
    "message": "Token has expired"
}
```

#### Invalid Refresh Token (401)
```json
{
    "message": "Invalid or expired refresh token"
}
```

#### Insufficient Permissions (403)
```json
{
    "message": "Unauthorized"
}
```

### Postman Collection

Import the provided `postman_collection.json` into Postman for easy testing. The collection includes:
- Pre-configured authentication requests
- Auto-save of tokens to environment variables
- All API endpoints with example requests

See `POSTMAN_SETUP.md` for detailed setup instructions.

## Testing Instructions

### Running Tests

```bash
# Run all tests
php artisan test

# Run specific test file
php artisan test --filter ProductTest
```

### Test Structure

```
tests/
├── Feature/              # Feature/Integration tests
│   └── Api/
│       └── V1/
│           ├── AuthTest.php
│           ├── ProductTest.php
│           ├── OrderTest.php
│           └── ProductVariantInventoryTest.php
└── Unit/                  # Unit tests
    └── ...
```

### Test Coverage

The test suite includes:

1. **Authentication Tests** (`AuthTest.php`)
   - User registration
   - User login
   - Token refresh
   - Authenticated user retrieval

2. **Product Tests** (`ProductTest.php`)
   - Product creation
   - Product listing
   - Product retrieval
   - Product update
   - Product deletion

3. **Order Tests** (`OrderTest.php`)
   - Order creation
   - Order listing
   - Order status updates
   - Order cancellation

4. **Product Variant Inventory Tests** (`ProductVariantInventoryTest.php`)
   - Variant quantity updates
   - Base product quantity updates

### Writing New Tests

#### Feature Test Example

```php
<?php

namespace Tests\Feature\Api\V1;

use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;

class MyFeatureTest extends TestCase
{
    use RefreshDatabase;

    public function test_something(): void
    {
        $response = $this->getJson('/api/v1/endpoint');
        
        $response->assertStatus(200)
            ->assertJson(['key' => 'value']);
    }
}
```

#### Testing with Authentication

```php
$user = User::factory()->create(['role' => 'admin']);
$token = auth('api')->login($user);

$response = $this->withHeader('Authorization', "Bearer {$token}")
    ->getJson('/api/v1/protected-endpoint');
```

### Database Testing

Tests use `RefreshDatabase` trait which:
- Runs migrations before each test
- Rolls back after each test
- Uses a separate test database

### Mocking Queue Jobs

```php
use Illuminate\Support\Facades\Queue;

Queue::fake();

// Your code that dispatches jobs

Queue::assertPushed(CheckLowStockJob::class);
```

### Testing Email Sending

```php
use Illuminate\Support\Facades\Mail;

Mail::fake();

// Your code that sends emails

Mail::assertSent(OrderConfirmationEmail::class);
```

## API Endpoints

### Authentication

-   `POST /api/v1/register` - Register new user
-   `POST /api/v1/login` - Login user
-   `POST /api/v1/refresh` - Refresh access token
-   `POST /api/v1/logout` - Logout user
-   `GET /api/v1/me` - Get authenticated user

### Products

-   `GET /api/v1/products` - List products (paginated)
-   `POST /api/v1/products` - Create product (Admin/Vendor)
-   `GET /api/v1/products/{id}` - Get product details
-   `PUT /api/v1/products/{id}` - Update product (Admin/Vendor)
-   `DELETE /api/v1/products/{id}` - Delete product (Admin/Vendor)
-   `GET /api/v1/products/search?q={query}` - Search products
-   `POST /api/v1/products/bulk-import` - Bulk import from CSV (Admin/Vendor)

### Orders

-   `GET /api/v1/orders` - List orders (filtered by role)
-   `POST /api/v1/orders` - Create order
-   `GET /api/v1/orders/{id}` - Get order details
-   `POST /api/v1/orders/{id}/confirm` - Confirm order (Admin/Vendor)
-   `POST /api/v1/orders/{id}/cancel` - Cancel order
-   `PUT /api/v1/orders/{id}/status` - Update order status (Admin/Vendor)

### Inventory

-   `GET /api/v1/inventory` - List inventory items (Admin/Vendor)
-   `PUT /api/v1/inventory/{productId}` - Update inventory (Admin/Vendor)
-   `GET /api/v1/inventory/low-stock` - Get low stock items (Admin/Vendor)

## Architecture

### Laravel Architecture Patterns

-   **Service Classes**: Business logic layer (`app/Services/`)
-   **Repository Pattern**: Data access layer (`app/Repositories/`)
-   **Actions/Commands**: Complex operations (`app/Actions/`)
-   **Events & Listeners**: Decoupled logic (`app/Events/`, `app/Listeners/`)
-   **Queue Jobs**: Async operations (`app/Jobs/`)
-   **Database Transactions**: Data integrity
-   **API Versioning**: v1 (`/api/v1/`)

### Performance & Scalability

-   Query optimization (N+1 prevention, eager loading)
-   Database indexing on searchable fields
-   Response pagination for large datasets
-   Database sharding strategy (see below)

## Database Sharding Strategy

### Overview

To handle high-volume transactions and ensure scalability, the system implements a **horizontal sharding strategy** based on order date and customer ID.

### Sharding Key

-   **Primary Shard Key**: `customer_id % shard_count`
-   **Secondary Shard Key**: Order creation date (monthly partitions)

### Implementation Strategy

1. **Order Table Sharding**

    - Orders are distributed across multiple databases based on `customer_id % N`
    - Each shard contains orders for a subset of customers
    - Shard routing is handled at the application level

2. **Product Table Sharding**

    - Products are sharded by `vendor_id % N`
    - Ensures vendor data is distributed evenly
    - Cross-shard queries use aggregation layer

3. **Inventory Table**
    - Co-located with products (same shard as product)
    - Reduces cross-shard joins
    - Inventory updates are atomic within shard

### Shard Configuration

```php
// config/sharding.php
return [
    'shards' => [
        'shard_1' => [
            'host' => env('SHARD_1_HOST', '127.0.0.1'),
            'database' => env('SHARD_1_DATABASE', 'ecom_shard_1'),
        ],
        'shard_2' => [
            'host' => env('SHARD_2_HOST', '127.0.0.1'),
            'database' => env('SHARD_2_DATABASE', 'ecom_shard_2'),
        ],
        // Add more shards as needed
    ],
    'shard_count' => env('SHARD_COUNT', 2),
];
```

### Shard Routing Logic

```php
// Example shard routing
$shardNumber = $customerId % $shardCount;
$connection = "shard_{$shardNumber}";
```

### Benefits

1. **Horizontal Scalability**: Add more shards as data grows
2. **Performance**: Queries are faster within a single shard
3. **Availability**: Failure of one shard doesn't affect others
4. **Load Distribution**: Even distribution of load across shards

### Considerations

1. **Cross-Shard Queries**: Use aggregation service for reporting
2. **Data Consistency**: Implement distributed transactions for critical operations
3. **Replication**: Each shard should have read replicas
4. **Monitoring**: Track query performance per shard

## Queue Jobs

The system uses Laravel queues for async operations:

-   `CheckLowStockJob` - Checks inventory levels and creates alerts
-   `GenerateInvoicePdf` - Generates PDF invoices for orders
-   `SendLowStockAlertEmail` - Sends email alerts for low stock

**Important**: Always run `php artisan queue:work` for these jobs to execute.

## Events & Listeners

-   `OrderCreated` → `SendOrderConfirmationEmail`
-   `OrderStatusChanged` → `SendOrderStatusUpdateEmail`

## Security

-   JWT authentication with refresh tokens
-   Role-based access control (RBAC)
-   Input validation via Form Requests
-   SQL injection prevention (Eloquent ORM)
-   XSS protection (Laravel's built-in protection)
-   Password hashing (bcrypt)
-   CSRF protection for web routes

## Performance Optimizations

1. **Database Indexing**

    - Indexes on frequently queried fields
    - Composite indexes for complex queries
    - Full-text indexes for search

2. **Query Optimization**

    - Eager loading to prevent N+1 queries
    - Query caching for frequently accessed data
    - Pagination for large datasets

3. **Caching**
    - Redis for session storage (optional)
    - Cache frequently accessed products
    - Cache user permissions

## Additional Documentation

- `POSTMAN_SETUP.md` - Postman collection setup guide
- `SEEDING_DATA.md` - Database seeding documentation

## Author

**Md. Hasan Sayeed**

- **Email**: jbhasan@gmail.com
- **GitHub**: [@jbhasan](https://github.com/jbhasan)

## License

The Laravel framework is open-sourced software licensed under the [MIT license](https://opensource.org/licenses/MIT).
